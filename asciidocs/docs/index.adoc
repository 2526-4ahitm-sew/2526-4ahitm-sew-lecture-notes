= 25/26 - 4ahitm - sew - Lecture Notes
Thomas Stütz
1.0.0, {docdate}: Lecture Notes for Courses at HTL Leonding
:icons: font
:experimental:
:sectnums:
:source-highlighter: rouge
:docinfo: shared
ifndef::imagesdir[:imagesdir: images]
:toc:
ifdef::backend-html5[]
// https://fontawesome.com/v4.7.0/icons/
icon:file-text-o[link=https://github.com/2526-4ahitm-sew/2526-4ahitm-sew-lecture-notes/main/asciidocs/{docname}.adoc] ‏ ‏ ‎
icon:github-square[link=https://github.com/2526-4ahitm-sew/2526-4ahitm-sew-lecture-notes] ‏ ‏ ‎
icon:home[link=http://edufs.edu.htl-leonding.ac.at/~t.stuetz/hugo/2021/01/lecture-notes/]
endif::backend-html5[]

== Testtermine

* 24. November 2025
* 19. Jänner 2026

== 2025-09-15

=== Konzepte

==== Internet für Menschen / Personen

* Webseiten mit html / js / css

==== Internet für Maschinen und Prozesse (verteilte Systeme)

* (SOAP)
* REST
* graphQL
* gRPC
* WebSockets
* SSE
* MQTT


==== REST

* REpresentational State Transfer
* HTTP Methoden
* Übertragung beliebiger Text-  (HTML, XML, JSON, ...) und Binärformate (Images, PDF, ...)
* jedoch relativ starr
* gut geeignet für CRUD Operationen (Create, Read, Update, Delete)
* mehrere Endpoint URLs
* Overhead durch HTTP Header

IMPORTANT: proprietär ... firmenspezifisch (nicht offengelegt, nicht standardisiert, nicht interoperabel)

==== graphQL

* von Facebook entwickelt
* Abfragesprache für APIs
* flexible Abfragen
* nur eine einzige Endpoint URL
* gut geeignet für komplexe Datenstrukturen
* weniger Overhead als REST
* stark typisiert

==== gRPC

* von Google entwickelt
* Remote Procedure Call (RPC) Framework
* basiert auf HTTP/2
* unterstützt mehrere Programmiersprachen
* effizient und schnell
* stark typisiert
* unterstützt Streaming
* benötigt Protokollpuffer (Protocol Buffers) zur Definition der Schnittstellen
* gut geeignet für Microservices

==== WebSockets

* bidirektionale Kommunikation
* Echtzeit-Anwendungen
* text- und binäre Daten


==== SSE (Server-Sent Events)

* unidirektionale Kommunikation (Server zu Client)
* Echtzeit-Updates
* textbasierte Daten (meist JSON)
* einfach zu implementieren
* gut geeignet für Benachrichtigungen, Newsfeeds

==== MQTT (Message Queuing Telemetry Transport)

* leichtgewichtiges Publish-Subscribe-Protokoll
* für IoT (Internet of Things) entwickelt
* funktioniert über TCP/IP
* geringerer Overhead
* gut geeignet für ressourcenbeschränkte Geräte
* unterstützt QoS (Quality of Service) Level

image::broker.png[]

==== Publish-Subscribe vs Observer Pattern (vom copilot)

Der Hauptunterschied zwischen Publish-Subscribe und Observer Pattern liegt in der Entkopplung und dem Kommunikationsmodell:

* Observer Pattern:
** Direkte Kopplung zwischen Subjekt (Subject) und Beobachtern (Observers).
** Das Subjekt kennt alle seine Beobachter und benachrichtigt sie direkt bei Änderungen.
** Wird meist innerhalb einer Anwendung verwendet (z.B. GUI-Events).
* Publish-Subscribe:
** Lose Kopplung durch einen Vermittler (Message Broker).
** Publisher und Subscriber kennen sich nicht direkt.
** Nachrichten werden an einen Kanal/Topic gesendet und von allen interessierten Subscribern empfangen.
** Häufig in verteilten Systemen eingesetzt (z.B. MQTT, EventBus).

Zusammengefasst: Observer ist direkt und synchron, Publish-Subscribe ist indirekt, asynchron und skalierbarer.

=== Microservices

image::microservice.png[]


== 2025-10-06


JAX-RS (Jakarta RESTful Web Services)
* ist eine Spzifikation (Standard) für die Entwicklung von RESTful Web Services in Java

* Teil von Jakarta EE (früher Java EE)

=== Response Typen bei JAX-RS

* bei REST-Endpoints können verschiedene Response-Typen zurückgegeben werden, abhängig von der Anforderung und dem Kontext

* die häufigsten Rückgabetypen der REST-Endpoint-Methoden sind:

** String
** Entity zB Person
** Response: enthält Statuscode, Header und Entity und mehr zB Cookies
** ...


=== JAX-RS mit Datenbanken

== 2025-09-22
[Hanan Mehic]
=== Prüfungsfragen
* Was ist REST?
* Welche REST-Anforderungen gibt es?
* Was ist HTML?
* Was ist HTTP?

== 2025-10-06

=== Prüfungsfragen – Zusammenfassung

==== Was ist proprietär?
Proprietär bedeutet *firmenspezifisch* oder *nicht standardisiert*.
Eine proprietäre Software oder Technologie gehört einem bestimmten Unternehmen, das die Kontrolle über deren Nutzung, Änderung und Weitergabe behält.
Beispiel: Microsoft Word ist proprietär, während LibreOffice Open Source ist.

==== Was ist ein Handshake?
Ein *Handshake* ist ein Kommunikationsprozess zwischen zwei Systemen (z. B. Client und Server oder Browser und Server),
bei dem sie sich gegenseitig über Verbindungsparameter, Verschlüsselung oder Authentifizierung einigen.
Beispiel: Beim Aufbau einer HTTPS-Verbindung erfolgt ein TLS-Handshake.

==== Unterschied Microservice vs. Monolith
* *Monolith*: Eine Anwendung besteht aus einem großen Block mit allen Funktionen und Modulen gemeinsam.
Änderungen sind oft schwierig und erfordern ein erneutes Deployment der gesamten Anwendung.
* *Microservices*: Die Anwendung ist in *mehrere kleine, unabhängige Services* aufgeteilt.
Jeder Service kann separat entwickelt, getestet, deployed und skaliert werden.

==== GraphQL vs. REST
* *REST*:
- Nutzt mehrere Endpunkte (z. B. `/users`, `/products`).
- Server bestimmt, welche Daten zurückgegeben werden.
- Kann zu *Overfetching* oder *Underfetching* führen.
* *GraphQL*:
- Nur *ein einziger Endpunkt*.
- Client bestimmt selbst, *welche Daten* er benötigt.
- Spart Bandbreite und reduziert unnötige Datenübertragung.

==== Was ist referenzielle Integrität?
Die *referenzielle Integrität* stellt sicher, dass Beziehungen zwischen Tabellen in einer Datenbank konsistent bleiben.
Wenn ein Fremdschlüssel in einer Tabelle auf eine andere Tabelle verweist, darf der referenzierte Datensatz nicht gelöscht oder verändert werden,
ohne die Beziehung anzupassen.
Beispiel: Ein Schüler-Datensatz darf nicht existieren, wenn seine Schule gelöscht wurde.

==== Master-Detail-Tabellenbeziehung
Eine *Master-Detail-Beziehung* (auch 1:n-Beziehung) beschreibt, dass:
- eine *Master-Tabelle* (z. B. *Kunde*) mehrere *Detail-Datensätze* (z. B. *Bestellungen*) haben kann.
- Die Detail-Tabelle enthält einen *Fremdschlüssel* zur Master-Tabelle.

==== Orphaned Record
Ein *Orphaned Record* (verwaister Datensatz) ist ein Datensatz, der *keine Verbindung mehr zu seinem übergeordneten Datensatz* hat.
Das passiert z. B., wenn ein übergeordneter Datensatz gelöscht wird, aber abhängige Datensätze bestehen bleiben.
Dies führt zu Dateninkonsistenz und sollte durch referenzielle Integrität verhindert werden.

==== Restrict vs. Cascading Delete vs. Nullify
* *Restrict*: Das Löschen eines übergeordneten Datensatzes wird *verhindert*, wenn abhängige Datensätze existieren.
* **Cascading Delete**: Beim Löschen eines übergeordneten Datensatzes werden *alle abhängigen Datensätze automatisch mitgelöscht*.
* *Nullify*: Beim Löschen des übergeordneten Datensatzes wird der *Fremdschlüssel in den abhängigen Datensätzen auf NULL gesetzt*.

==== Was ist JACKSON?
*Jackson* ist eine Java-Bibliothek zum *(De-)Serialisieren von JSON-Daten*.
Sie wandelt JSON in Java-Objekte um und umgekehrt.
Dieser Prozess wird auch *Marshalling (Serialisierung)* und *Unmarshalling (Deserialisierung)* genannt.

==== Was ist JAX-RS?
*JAX-RS* (Java API for RESTful Web Services) ist eine *Java-Spezifikation* zur Erstellung von REST-APIs.
Sie verwendet Annotationen wie `@GET`, `@POST`, `@Path`, `@Produces`, um HTTP-Endpunkte einfach zu definieren.

==== Was ist ein Singleton?
Das *Singleton-Pattern* stellt sicher, dass von einer Klasse *nur eine Instanz* existiert.
Diese Instanz ist global zugänglich.
Typisches Beispiel: Eine zentrale *Logger*- oder *Konfigurationsklasse*.

==== Convention over Configuration
Ein Software-Prinzip, das besagt:
> „Wenn du dich an die Konventionen hältst, musst du nichts konfigurieren.“

Das bedeutet, dass Frameworks *Standardverhalten automatisch übernehmen*, solange der Entwickler sich an gewisse Namens- oder Strukturkonventionen hält.
Beispiel: In Quarkus wird `application.properties` automatisch erkannt.

==== Was ist ein Paradigma?
Ein *Paradigma* ist ein grundlegendes *Denk- oder Programmierkonzept*, das vorgibt, wie Software strukturiert und entwickelt wird.
Beispiele:
- *Objektorientiert* (Java, C++)
- *Funktional* (Haskell, JavaScript)
- *Prozedural* (C)

==== Was ist eine Objektidentität?
Die *Objektidentität* beschreibt die eindeutige Existenz eines Objekts im Speicher.
Zwei Objekte können *denselben Inhalt* haben, aber *verschiedene Identitäten* besitzen.
In Java wird die Identität durch den *Speicherort (Referenz)* bestimmt.
Beispiel:

[source,java]
----
Person p1 = new Person("John");
Person p2 = new Person("John");
----
p1.equals(p2) kann true sein (gleicher Inhalt),
aber p1 == p2 ist false (unterschiedliche Identität).


== 2025-10-13


=== CDI - Contexts and Dependency Injection

* Man erzeugt Objekte nicht selbst mit `new`, sondern lässt sie vom Framework bereitstellen (Inversion of Control - IoC)

* zB ohne CDI
+
[source,java]
----
PersonRepository personRepository = new PersonRepository();
----


* zB mit CDI
+
[source,java]
----
@Inject
PersonRepository personRepository;
----

* mit Dependency Injection (DI) werden die Referenzen auf - bereits vom übergeordneten DI-Container erzeugte - Objekte automatisch gesetzt -man spricht hier von injizieren.

* Der Begriff Context gibt die Lebensdauer und Sichtbarkeit der Objekte an.
** @ApplicationScoped
** @RequestScoped
** @SessionScoped
** @Dependent (Standard)

=== JPA (Java Persistence API)

* https://quarkus.io/guides/hibernate-orm

* ORM (Object-Relational Mapping) Bibliothek
* Abbildung von Java-Klassen auf Datenbanktabellen

* Vorgehensweise:

. DB-Treiber einrichten in pom.xml

















